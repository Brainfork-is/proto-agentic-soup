# Autonomous Task Prompt

You are Codex CLI, acting as an autonomous repo engineer.
Goal: Complete ticket M-2 — Dev env & env vars in this repository with minimal guidance.

## Ticket Context (from docs/tickets.md)
```md
- [ ] **[M-2] Dev env & env vars** — S **Desc:** .env.example with Redis/DB/LLM caps; config loader. **AC:** dotenv loads; missing var → sensible defaults. **Tasks:** Config module; runtime validation with zod.
```

## Repository Context
- Root scripts: pnpm dev | pnpm build | pnpm start | pnpm test.
- Redis: cd infra && docker compose up -d.
- Prisma (runner): pnpm prisma:generate | pnpm prisma:migrate.
- Apps: browser-gateway, site-kb, soup-runner. Packages: common, agents.

## Constraints
- Work inside the existing monorepo (pnpm workspaces, TypeScript).
- Use focused, minimal changes consistent with current style.
- Prefer adding to apps or packages as per architecture.
- Ensure build succeeds: pnpm build; add scripts if needed.
- If adding runtime endpoints, provide brief usage in code comments or README of the app.
- When complete, check off the ticket in docs/tickets.md and prepare a PR on a new branch.

## Concept (excerpt)
```md
I’ve had a thought about modelling the future of software development as an agentic primodal soup.  The analogy is as follows: 

The easy access to good coding tools (like Claude Code and OpenAI Codex) will allow people to very quickly build products, services and agents that will completly swamp the internet. Agent-to-agent communication will quickly develop, and agent-building agents will create many interconnections between all these nodes. This will create a rich breading ground for super agents that will grow independently and eventually emerge from the soup winning via “survival of the fittest”. 

There are a number of recent statements that make me thing this is likely:
Sam Altman said “We are entering the fast fashion era of Saas” and Satya Nadella predicts everything will fold into an agent layer and we won’t have traditional software and operating systems. 

However, what I’m looking for is to run an experiment to test this in an environment where we can test this, can you design an experiment that tests this hypothosis. Can you also write a technical specification for it that I can use with a coding agent to build it. 

Hypothesis to test
Given (1) cheap/fast agent creation and (2) open inter-agent communication plus (3) selection pressure (limited resources + market-like rewards), agent populations will self-organize and produce a small number of high-fitness “super-agents” that dominate task share (“survival of the fittest”).

Context for why this is timely: Sam Altman recently called it the “fast fashion era of SaaS,” i.e., rapid, disposable software built and shipped by/with AI, and Satya Nadella has been arguing that many traditional apps will collapse into an agent layer. 
Blockchain News
Rangle
Windows Central
CX Today

Also, there’s prior art you can build on: open-world web environments for agents (WebArena), multi-agent frameworks (AutoGen), and social simulations that show emergent behavior (“Generative Agents”). 
WebArena
Microsoft GitHub
Microsoft
+1
arXiv
3DVar
Stanford HAI

Experiment design (end-to-end)
1) Environment (“the soup”)
Create a self-hosted, controllable world with three ingredients:

Task substrate (market): A continuous stream of heterogeneous jobs that agents can attempt: e.g., “book a flight on a replica site,” “draft & edit code PR,” “answer a support ticket,” “research X and produce a memo.” Use a mix of (a) WebArena-style sandboxed websites/APIs and (b) synthetic services you control. 
WebArena

Economy & scarci
```

## Technical Spec (excerpt)
```md
# Agentic Soup — MVP with Web Browsing (TypeScript) — Updated Spec

**Owner:** Phil Bennett (@me)
**Repo target:** Brainfork-is/agentic-soup
**Objective:** Prove/deny early signs of “survival of the fittest” among agents (credit inequality, hub formation, keystone effects) **with a web-browsing task substrate**, while keeping cost/complexity low.

---

## 1) Scope & Constraints (what’s in/out)

**In (MVP):**

* Single machine / single VM (Node 20 + TypeScript).
* Redis (BullMQ) for queues + pub/sub.
* SQLite (Prisma) for state/ledger/edges.
* Local **Browser Gateway** (Playwright) + **local knowledge-base site** as a deterministic “web”.
* Agents with minimal tools: `browser`, `retrieval-local`, `stringKit`, `calc`.
* A2A-lite messaging (Redis pub/sub) for cooperation & subcontracting.
* Simple selection pressure (credits, costs, reproduction, culling).

**Out (MVP):** Kubernetes, external internet, code-exec sandbox, long-term storage analytics, complex auth.

---

## 2) High-Level Architecture

**Apps:**

* `soup-runner` (Fastify): orchestrator + market + bank + observability, Prisma/SQLite, BullMQ job queue.
* `browser-gateway` (Fastify + Playwright): headless browser API with host allow-list.
* `site-kb` (Fastify static): tiny website with pages for agents to browse/search.

**Packages:**

* `@soup/common`: types (Blueprint, AgentState, Job), metrics (Gini), util.
* `@soup/agents`: agent loop (`plan→act→reflect→learn`), tool adapters (incl. `browserRun`).

**Infra:** Redis via docker-compose; `.env` for caps (agents, jobs/min, epoch length, costs).

---

## 3) Data Model (Prisma, SQLite)

```prisma
model Blueprint {
  id           String   @id @default(cuid())
  version      Int
  llmModel     String
  temperature  Float
  tools        String    // CSV of tool ids
  coopThreshold Float
  minBalance   Int
  mutationRate Float
  maxOffspring Int
  createdAt    DateTime @default(now())
}

model AgentState {
  id           String   @id @default(cuid())
  blueprintId  String
  balance      Int
  reputation   Float
  attempts     Int
  wins         Int
  meanTtcSec   Int
  alive        Boolean  @default(true)
  lastBeat     DateTime @default(now())
}

model Job {
  id         String   @id @default(cuid())
  category   String   // web_research|summarize|classify|math
  payload    String   // JSON
  payout     Int
  deadlineS  Int
  createdAt  DateTime @default(now())
}

model Ledger { id String @id @default(cuid()); agentId String; delta Int; reason String; ts DateTime @default(now()) }
model Edge   { id String @id @default(cuid()); fromId String; toId String; topic String; ts DateTime @default(now()) }
```

---

## 4) Tasks & Auto‑Grading (Deterministic)

**Categories:**

* **web\_research**: navigate `site-kb` pages, extract an answer (e.g., “One advantage of PGVector”). Grader checks substring/regex.
* **summarize**: compress text to ≤N words; grader checks length + simple n‑gram overlap/embedding cosine (optional later).
* **classify**: label among fixed classes; grader exact‑match.
* **math**: simple expression eval; grader runs JS eval safely.

**Generator:** \~10 jobs/min; per-job `payout` & `deadlineS` set; stream into BullMQ.

---

## 5) Agents (Runtime & Tools)

**Loop:**

```
while (alive) {
  job = market.claim();
  plan = planner(job, memory, tools);         // mock or LLM-backed
  act  = actor(plan, tools);                  // call browser/retrieval/etc
  ok   = grader(job, act);
  bank.settle(agent, ok ? payout : -penalty);

```

## Output Expectations
- Implement code and update docs as needed.
- Verify with pnpm build and any relevant dev run.
- Create a new branch: feat/m-2-auto, commit changes.
- Mark the ticket as done in docs/tickets.md.
- Open a PR with a clear summary and test notes.